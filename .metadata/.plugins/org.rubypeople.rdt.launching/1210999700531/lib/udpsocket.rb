=begin
------------------------------------------------------- Class: UDPSocket
     Class +Socket+ provides access to the underlying operating system
     socket implementations. It can be used to provide more operating
     system specific functionality than the protocol-specific socket
     classes but at the expense of greater complexity. In particular,
     the class handles addresses using +struct sockaddr+ structures
     packed into Ruby strings, which can be a joy to manipulate.

     Exception Handling
     Ruby's implementation of +Socket+ causes an exception to be raised
     based on the error generated by the system dependent
     implementation. This is why the methods are documented in a way
     that isolate Unix-based system exceptions from Windows based
     exceptions. If more information on particular exception is needed
     please refer to the Unix manual pages or the Windows WinSock
     reference.

     Documentation by
     *   Zach Dennis

     *   Sam Roberts

     *   _Programming Ruby_ from The Pragmatic Bookshelf.

     Much material in this documentation is taken with permission from
     _Programming Ruby_ from The Pragmatic Bookshelf.

------------------------------------------------------------------------


Instance methods:
-----------------
     bind, connect, recvfrom_nonblock, send

=end
class UDPSocket < IPSocket
  include File::Constants
  include Enumerable

  # --------------------------------------------------------- UDPSocket#send
  #      send(mesg, flags, *rest)
  # ------------------------------------------------------------------------
  #      (no description...)
  def send(arg0, arg1, *rest)
  end

  # --------------------------------------------------------- UDPSocket#bind
  #      bind(host, port)
  # ------------------------------------------------------------------------
  #      (no description...)
  def bind(arg0, arg1)
  end

  # -------------------------------------------- UDPSocket#recvfrom_nonblock
  #      udpsocket.recvfrom_nonblock(maxlen) => [mesg, sender_inet_addr]
  #      udpsocket.recvfrom_nonblock(maxlen, flags) => [mesg,
  #      sender_inet_addr]
  # ------------------------------------------------------------------------
  #      Receives up to _maxlen_ bytes from +udpsocket+ using recvfrom(2)
  #      after O_NONBLOCK is set for the underlying file descriptor. _flags_
  #      is zero or more of the +MSG_+ options. The first element of the
  #      results, _mesg_, is the data received. The second element,
  #      _sender_inet_addr_, is an array to represent the sender address.
  # 
  #      When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns an
  #      empty string as data. It means an empty packet.
  # 
  #      Parameters
  #      *   +maxlen+ - the number of bytes to receive from the socket
  # 
  #      *   +flags+ - zero or more of the +MSG_+ options
  # 
  #      Example
  #           require 'socket'
  #           s1 = UDPSocket.new
  #           s1.bind("127.0.0.1", 0)
  #           s2 = UDPSocket.new
  #           s2.bind("127.0.0.1", 0)
  #           s2.connect(*s1.addr.values_at(3,1))
  #           s1.connect(*s2.addr.values_at(3,1))
  #           s1.send "aaa", 0
  #           IO.select([s2])
  #           p s2.recvfrom_nonblock(10)  #=> ["aaa", ["AF_INET", 33302, "localhost.localdomain", "127.0.0.1"]]
  # 
  #      Refer to Socket#recvfrom for the exceptions that may be thrown if
  #      the call to _recvfrom_nonblock_ fails.
  # 
  #      UDPSocket#recvfrom_nonblock may raise any error corresponding to
  #      recvfrom(2) failure, including Errno::EAGAIN.
  # 
  #      See
  #      *   Socket#recvfrom
  # 
  def recvfrom_nonblock(arg0, arg1, *rest)
  end

  # ------------------------------------------------------ UDPSocket#connect
  #      connect(host, port)
  # ------------------------------------------------------------------------
  #      (no description...)
  def connect(arg0, arg1)
  end

end
